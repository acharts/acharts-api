<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">
var Raphael = require(&#39;achart-raphael&#39;),
  STEP_MS = 16,//16毫秒一个step
  HANDLERS = {

  },
  TIMES = {},//动画的事件校验
  NAN = NaN,
  PRE_HAND = &#39;h&#39;,
  objectPrototype = Object.prototype,
  toString = objectPrototype.toString;
  

//取小于当前值的
function floor(values,value){
  var length = values.length,
    pre = values[0];
  if(value &lt; values[0]){
    return NAN;
  }
  if(value &gt;= values[length - 1]){
    return values[length - 1];
  }
  for (var i = 1; i &lt; values.length; i++) {
    if(value &lt; values[i]){
      break;
    }
    pre = values[i];
  }

  return pre;
}
//大于当前值的第一个
function ceiling(values,value){
  var length = values.length,
    pre = values[0],
    rst;
  if(value &gt; values[length - 1]){
    return NAN;
  }
  if(value &lt; values[0]){
    return values[0];
  }

  for (var i = 1; i &lt; values.length; i++) {
    if(value &lt;= values[i]){
      rst = values[i];
      break;
    }
    pre = values[i];
  }

  return rst;
}

//将数值逼近到指定的数
function tryFixed(v,base){
  var str = base.toString(),
    index = str.indexOf(&#39;.&#39;);
  if(index == -1){
    return parseInt(v);
  }
  var length = str.substr(index + 1).length;
  return parseFloat(v.toFixed(length));
}
//分步动画
function animTime(duration,fn,callback){
    var baseTime = new Date().getTime(),
      baseInterval = 16,
      uid = Util.guid(PRE_HAND);

    next(0,fn,duration,callback);
    function next(num,fn,duration,callback){
      var nowTime = new Date().getTime();
      var durTime = nowTime - baseTime;
      if(durTime &gt;= duration){
        fn(1,num);
        callback &amp;&amp; callback();
        return ;
      }

      var factor = Math.pow(durTime/duration, 1.7);
      fn(factor,num);
      HANDLERS[uid] =  Util.requestAnimationFrame(function(){
        next(num+1,fn,duration,callback);
      });
    }
    return uid;
  } 

function stopStep(uid){
  if(HANDLERS[uid]){
      Util.cancelAnimationFrame(HANDLERS[uid]);
    delete HANDLERS[uid];
    //delete TIMES[uid];
  }
}

var MAX_LEVEL = 5;

function deepMix(dst,src,level){
  level = level || 0;
  for(var k in src){
    if(src.hasOwnProperty(k)){
      var value = src[k];
      if(value !== null &amp;&amp; Util.isObject(value)){
        if(!Util.isObject(dst[k])){
          dst[k] =  {};
        }
        if(level &lt; MAX_LEVEL){
          deepMix(dst[k],src[k]);
        }else{
          dst[k] = src[k];
        }
      }else if(Util.isArray(value)){
        //if(!Util.isArray(dst[k])){
        dst[k] = [];
        //}
        dst[k] = dst[k].concat(value);
      }else if(value !== undefined){
        dst[k] = src[k];
      }
    }
  }
}

<span id='Chart-Util'>/**
</span> * @class Chart.Util
 * @singleton
 * 绘图的工具类
 */
var Util = {

<span id='Chart-Util-method-substitute'>  /**
</span>     * 替换字符串中的字段.
     * @param {String} str 模版字符串
     * @param {Object} o json data
     * @param {RegExp} [regexp] 匹配字符串的正则表达式
     */

    substitute: function (str, o) {
      if(!str || !o){
        return str;
      }
      return str.replace(/\\?\{([^{}]+)\}/g, function (match, name) {
        if (match.charAt(0) === &#39;\\&#39;) {
            return match.slice(1);
        }
        return (o[name] === undefined) ? &#39;&#39; : o[name];
      });
    },
<span id='Chart-Util-method-ucfirst'>    /**
</span>     * 使第一个字母变成大写
     * @param  {String} s 字符串
     * @return {String} 首字母大写后的字符串
     */
    ucfirst : function(s){
        s += &#39;&#39;;
        return s.charAt(0).toUpperCase() + s.substring(1);
    },
<span id='Chart-Util-method-isString'>    /**
</span>     * 判断是否是字符串
     * @return {Boolean} 是否是字符串
     */
    isString : function(value){
        return typeof value === &#39;string&#39;;
    },
<span id='Chart-Util-method-isNumber'>    /**
</span>     * 判断是否数字
     * @return {Boolean} 是否数字
     */
    isNumber : function(value){
        return typeof value === &#39;number&#39;;
    },
<span id='Chart-Util-method-isNumeric'>    /**
</span>     * 判断是否数字或者数字字符串，由于$.isNumberic方法会把 &#39;123&#39;认为数字
     * @return {Boolean} 是否数字
     */
    isNumeric : function(value){
      return !isNaN(parseFloat(value)) &amp;&amp; isFinite(value);
    },
<span id='Chart-Util-method-isBoolean'>    /**
</span>     * 是否是布尔类型
     *
     * @param {Object} value 测试的值
     * @return {Boolean}
     */
    isBoolean: function(value) {
        return typeof value === &#39;boolean&#39;;
    },
<span id='Chart-Util-method-isFunction'>    /**
</span>     * 是否为函数
     * @param  {*} fn 对象
     * @return {Boolean}  是否函数
     */
    isFunction : function(fn){
        return typeof(fn) === &#39;function&#39;;
    },
<span id='Chart-Util-method-isArray'>    /**
</span>     * 是否数组
     * @method
     * @param  {*}  obj 是否数组
     * @return {Boolean}  是否数组
     */
    isArray : (&#39;isArray&#39; in Array) ? Array.isArray : function(value) {
        return toString.call(value) === &#39;[object Array]&#39;;
    },

<span id='Chart-Util-method-isDate'>    /**
</span>     * 是否日期
     * @param  {*}  value 对象
     * @return {Boolean}  是否日期
     */
    isDate: function(value) {
        return toString.call(value) === &#39;[object Date]&#39;;
    },
<span id='Chart-Util-method-isObject'>    /**
</span>     * 是否是javascript对象
     * @param {Object} value The value to test
     * @return {Boolean}
     * @method
     */
    isObject: (toString.call(null) === &#39;[object Object]&#39;) ?
        function(value) {
            // check ownerDocument here as well to exclude DOM nodes
            return value !== null &amp;&amp; value !== undefined &amp;&amp; toString.call(value) === &#39;[object Object]&#39; &amp;&amp; value.ownerDocument === undefined;
        } :
        function(value) {
            return toString.call(value) === &#39;[object Object]&#39;;
        },

<span id='Chart-Util-method-extend'>    /**
</span>     * 实现类的继承，通过父类生成子类
     * @param  {Function} subclass
     * @param  {Function} superclass 父类构造函数
     * @param  {Object} overrides  子类的属性或者方法
     * @return {Function} 返回的子类构造函数
     * 示例:
     *      @example
     *      //父类
     *      function base(){
     *  
     *      }
     *
     *      function sub(){
     * 
     *      }
     *      //子类
     *      Util.extend(sub,base,{
     *          method : function(){
     *    
     *          }
     *      });
     *
     *      //或者
     *      var sub = Util.extend(base,{});
     */
    extend : function(subclass,superclass,overrides, staticOverrides){
        //如果只提供父类构造函数，则自动生成子类构造函数
        if(!Util.isFunction(superclass))
        {
            overrides = superclass;
            superclass = subclass;
            subclass =  function(){};
        }

        var create = Object.create ?
          function (proto, c) {
              return Object.create(proto, {
                  constructor: {
                      value: c
                  }
              });
          } :
          function (proto, c) {
              function F() {
              }

              F.prototype = proto;

              var o = new F();
              o.constructor = c;
              return o;
          };
            
        var superObj = create(superclass.prototype,subclass);//new superclass(),//实例化父类作为子类的prototype
        subclass.prototype = Util.mix(superObj,subclass.prototype);     //指定子类的prototype
        subclass.superclass = create(superclass.prototype,superclass);
        Util.mix(superObj,overrides);
        Util.mix(subclass,staticOverrides);
        return subclass;
    },
<span id='Chart-Util-method-augment'>    /**
</span>     * 复制到原型链上
     * @param  {Function} c   类
     * @param  {Object} obj 对象
     */
    augment : function(c){

      var args = Util.toArray(arguments);
      for(var i = 1;i &lt; args.length; i++){
        var obj = args[i];
        if(Util.isFunction(obj)){
            obj = obj.prototype;
        }
        Util.mix(c.prototype,obj);
      }
    },
<span id='Chart-Util-method-toArray'>    /**
</span>     * 转换成数组
     * @param  {*} value 需要转换的对象
     * @return {Array}  数组
     */
    toArray: function (value) { 
      if(!value || !value.length){
        return [];
      }
      if(Util.vml){
        var rst = [];
        for(var i = 0; i &lt; value.length; i++){
          rst.push(value[i]);
        }
        return rst;
      }else{
        return Array.prototype.slice.call(value); 
      }
      
    },
<span id='Chart-Util-method-mix'>    /**
</span>     * 合并数据
     * @return {Object} 将数据合并到第一个
     */
    mix : function(){
      var args = Util.toArray(arguments),
        obj = args[0];
      if(obj == true){
        obj = args[1];
        for(var i = 2;i &lt; args.length; i++){
          var source = args[i];
          deepMix(obj,source);
        }
      }else{
        for(var i = 1;i &lt; args.length; i++){
          var source = args[i];
          for(var k in source){
            if(source.hasOwnProperty(k) &amp;&amp; k != &#39;constructor&#39;){
              obj[k] = source[k];
            }
          }
        }
      }

      
      return obj;
    },
    mixin : function(c,mixins){
      if(c &amp;&amp; mixins){
        c._mixins = mixins;
        c.ATTRS = c.ATTRS || {};
        var temp = {};
        Util.each(mixins,function(mixin){
          Util.augment(c,mixin);
          var attrs = mixin.ATTRS;
          if(attrs){
            Util.mix(temp,attrs);
          }
        });

        c.ATTRS = Util.mix(temp,c.ATTRS);
      }
    },
<span id='Chart-Util-method-map'>    /**
</span>     * map 数组
     * @param  {Array} arr 数组
     * @return {Array} map后的数组
     */
    map : function(arr,func){
      var result = [];
      Util.each(arr,function(value,index){
        result.push(func(value,index));
      });
      return result;
    },
<span id='Chart-Util-method-filter'>   /**
</span>     * 过滤数组
     * @param {Object|Array} element/Object 数组中的元素或者对象的值 
     * @param {Function} func 遍历的函数 function(elememt,index){} 或者 function(value,key){},如果返回true则添加到结果集
     * @return {Array} 过滤的结果集
     */
    filter : function(array,func){
      var result = [];
      Util.each(array,function(value,index){
        if(func(value,index)){
          result.push(value);
        }
      });
      return result;
    },
<span id='Chart-Util-method-each'>    /**
</span>     * 遍历数组或者对象
     * @param {Object|Array} element/Object 数组中的元素或者对象的值
     * @param {Function} func 遍历的函数 function(elememt,index){} 或者 function(value,key){}
     */
    each : function (elements,func) {
      if(!elements){
          return;
      }
      if(Util.isObject(elements)){
        for(var k in elements){
          if(elements.hasOwnProperty(k)){
           var rst = func(elements[k],k);
           if(rst == false){
             break;
           }
          }
        }
      }else if(elements.length){
        for (var i = 0; i &lt; elements.length ; i++) {
          var rst = func(elements[i],i);
          if(rst == false){
             break;
           }
        };
      }
    },
    requestAnimationFrame : function(fn){
        var method = window.requestAnimationFrame 
        || window.webkitRequestAnimationFrame 
        || function(fn){
           return setTimeout(fn,16);
        };
        
        return method(fn);
    },
    cancelAnimationFrame : function(id){
        var method = window.cancelAnimationFrame 
        || window.webkitCancelAnimationFrame 
        || function(id){
           return clearTimeout(id);
        }; 
        return  method(id);
    },
<span id='Chart-Util-method-guid'>    /**
</span>     * 生成唯一的Id
     * @method
     * @param {String} prefix 前缀
     * @return {String} 唯一的编号
     */
    guid : (function(){
        var map = {};
        return function(prefix){
            prefix = prefix || &#39;acharts&#39;;
            if(!map[prefix]){
                map[prefix] = 1;
            }else{
                map[prefix] += 1;
            }
            return prefix + map[prefix];
        };
    })(),

    indexOf : function(arr,obj){
      var m = Array.prototype.indexOf;
      if(m){
        return m.call(arr,obj);
      }
      var index = -1;

      for(var i = 0 ; i &lt; arr.length; i++){
        if(arr[i] == obj){
          index = i;
          break;
        }
      }
      return index;
    },
<span id='Chart-Util-method-remove'>    /**
</span>     * 删除
     */
    remove : function(arr,obj){
      var index = Util.indexOf(arr,obj);
      if(index !== -1){
        arr.splice(index,1);
      }
    },
<span id='Chart-Util-method-empty'>    /**
</span>     * 清空
     * @param  {Array} array 数组
     */
    empty : function(array){
      if(!(array instanceof(Array))){
        for (var i = array.length - 1; i &gt;= 0; i--) {
          delete array[i];
        }
      }
      array.length = 0;
    },
<span id='Chart-Util-method-equalsArray'>    /**
</span>     * 2个数组是否等同
     * @param  {Array} a1 数组1
     * @param  {Array} a2 数组2
     * @return {Boolean} 2个数组相等或者内部元素是否相等
     */
    equalsArray : function(a1,a2){
      if(a1 == a2){
        return true;
      }
      if(!a1 || !a2){
        return false;
      }

      if(a1.length != a2.length){
        return false;
      }
      var rst = true;
      for(var i = 0 ;i &lt; a1.length; i++){
        if(a1[i] !== a2[i]){
          rst = false;
          break;
        }
      }
      return rst;
    },
<span id='Chart-Util-method-wrapBehavior'>    /**
</span>     * 封装事件，便于使用上下文this,和便于解除事件时使用
     * @protected
     * @param  {Object} self   对象
     * @param  {String} action 事件名称
     */
    wrapBehavior : function(self, action) {
        return self[&#39;_wrap_&#39; + action] = function (e) {
          self[action](e);
        };
    },
<span id='Chart-Util-method-getWrapBehavior'>    /**
</span>     * 获取封装的事件
     * @protected
     * @param  {Object} self   对象
     * @param  {String} action 事件名称
     */
    getWrapBehavior : function(self, action) {
        return self[&#39;_wrap_&#39; + action];
    }
};


var ARR_EV = [&#39;srcElement&#39;,&#39;toElement&#39;,&#39;clientX&#39;,&#39;clientY&#39;,&#39;keyCode&#39;];

function getEventObj(ev){
  var  rst = {};
  rst.target = ev.srcElement;
  rst.pageX = ev.clientX + document.body.scrollLeft - document.body.clientLeft;
  rst.pageY = ev.clientY + document.body.scrollTop - document.body.clientTop;
  Util.each(ARR_EV,function(key){
    rst[key] = ev[key];
  });
  return rst;
}

var fragmentRE = /^\s*&lt;(\w+|!)[^&gt;]*&gt;/,
  table = document.createElement(&#39;table&#39;),
  tableRow = document.createElement(&#39;tr&#39;),
  containers = {
      &#39;tr&#39;: document.createElement(&#39;tbody&#39;),
      &#39;tbody&#39;: table, &#39;thead&#39;: table, &#39;tfoot&#39;: table,
      &#39;td&#39;: tableRow, &#39;th&#39;: tableRow,
      &#39;*&#39;: document.createElement(&#39;div&#39;)
  };

Util.mix(Util,{


<span id='Chart-Util-property-vml'>  /**
</span>   * 是否是vml
   * @type {Boolean}
   */
  vml : Raphael.vml,
<span id='Chart-Util-property-svg'>  /**
</span>   * 是否是svg
   * @type {Boolean}
   */
  svg : Raphael.svg,
<span id='Chart-Util-method-createDom'>  /**
</span>   * 创建DOM 节点
   * @param  {String} str Dom 字符串
   * @return {HTMLElement}  DOM 节点
   */
  createDom : function(str){
    var name = fragmentRE.test(str) &amp;&amp; RegExp.$1;

    if (!(name in containers)){
      name = &#39;*&#39;
    }
    container = containers[name];
    str = str.replace(/(^\s*)|(\s*$)/g, &quot;&quot;);
    container.innerHTML = &#39;&#39; + str;
    return container.childNodes[0];
  },
  getOffset : function(o){
    var rst = {},
      left = 0,
      top = 0;
    while (o!=null &amp;&amp; o!=document.body){
    
        left += (o.offsetLeft || 0);
        top += (o.offsetTop || 0);
        o = o.offsetParent;
    };
    rst.top = top;
    rst.left = left;
    return rst;
  },
<span id='Chart-Util-method-contains'>  /**
</span>   * 是否包含指定节点
   * @param  {HTMLElement} node    节点
   * @param  {HTMLElement} subNode 子节点
   * @return {HTMLElement} 是否包含在节点中
   */
  contains : function(node,subNode){
      if(!node || !subNode){
        return false;
      }
      var rst = false,
        parent = subNode.parentNode;
      while(parent!=null &amp;&amp; parent!=document.body){
        if(parent == node){
          rst = true;
          break;
        }
        parent = parent.parentNode;
      }

      return rst;
  },
<span id='Chart-Util-method-getWidth'>  /**
</span>   * 获取宽度
   * @param  {HTMLElement} el  dom节点
   * @return {Number} 宽度
   */
  getWidth : function(el){
    var width = Util.getStyle(el,&#39;width&#39;);
    if(width == &#39;auto&#39;){
      width = el.offsetWidth;
    }
    return parseFloat(width);
  },
<span id='Chart-Util-method-getHeight'>   /**
</span>   * 获取高度
   * @param  {HTMLElement} el  dom节点
   * @return {Number} 高度
   */
  getHeight : function(el){
    var height = Util.getStyle(el,&#39;height&#39;);
    if(height == &#39;auto&#39;){
      height = el.offsetHeight;
    }
    return parseFloat(height);
  },
  getOuterWidth : function(el){
    var width = Util.getWidth(el),
      bLeft = parseFloat(Util.getStyle(el,&#39;borderLeftWidth&#39;)) || 0,
      pLeft = parseFloat(Util.getStyle(el,&#39;paddingLeft&#39;)),
      pRight = parseFloat(Util.getStyle(el,&#39;paddingRight&#39;)),
      bRight = parseFloat(Util.getStyle(el,&#39;borderRightWidth&#39;)) || 0;

    return width + bLeft + bRight + pLeft + pRight;
  },
  getOuterHeight : function(el){
     var height = Util.getHeight(el),
      bTop = parseFloat(Util.getStyle(el,&#39;borderTopWidth&#39;)) || 0,
      pTop = parseFloat(Util.getStyle(el,&#39;paddingTop&#39;)),
      pBottom = parseFloat(Util.getStyle(el,&#39;paddingBottom&#39;)),
      bBottom = parseFloat(Util.getStyle(el,&#39;borderBottomWidth&#39;)) || 0;

    return height + bTop + bBottom + pTop + pBottom;
  },
<span id='Chart-Util-method-getStyle'>  /**
</span>   * 获取样式
   * @param  {HTMLElement} el  dom节点
   * @param  {String} name 样式名
   * @return {String} 属性值
   */
  getStyle : function(el,name){
    if(window.getComputedStyle){
      return window.getComputedStyle(el,null)[name];
    }
    return el.currentStyle[name];
  },
  addEvent : function( obj, type, fn ) {
    if ( obj.attachEvent ) {
        obj[&#39;e&#39;+type+fn] = fn;
        obj[type+fn] = function(){
          window.event.target = window.event.srcElement;
          obj[&#39;e&#39;+type+fn]( getEventObj(window.event) );
        }
        obj.attachEvent( &#39;on&#39;+type, obj[type+fn] );
    } else
        obj.addEventListener( type, fn, false );
  },
  removeEvent : function( obj, type, fn ) {
      if ( obj.detachEvent ) {
          obj.detachEvent( &#39;on&#39;+type, obj[type+fn] );
          obj[type+fn] = null;
      } else
          obj.removeEventListener( type, fn, false );
  },
  angle : function(x1, y1, x2, y2){
    return Raphael.angle(x1, y1, x2, y2);
  },
<span id='Chart-Util-method-animStep'>  /**
</span>   * 分步执行动画
   * @param  {Number}   duration 执行时间
   * @param  {Function} fn  每一步执行的回调函数，function(step,total){}
   * @param  {Function} callback 回调函数
   * @return {String} 动画的handler用于终止动画
   */
  animStep : function(duration,fn,callback){
    return  animTime(duration,fn,callback);
  },
<span id='Chart-Util-method-stopStep'>  /**
</span>   * 终止分步执行的动画
   * @param  {String} handler 句柄
   */
  stopStep : function(handler){
    stopStep(handler);
  },
  animPath : function(pathShape,toPath,reserve,duration,easing,callback){
    //vml阻止动画执行
    /**/
    if(Util.vml){
      after();
      return;
    }
    reserve = reserve || 0;
    duration = duration || 400;

    var curPath = pathShape.getPath(),
      endPath = Util.parsePathString(toPath),
      tempPath,
      last = curPath.slice(reserve * -1);

    if(curPath.length &gt; endPath.length){
      tempPath = curPath.slice(0,endPath.length);
    }else{
      tempPath = curPath.concat([]);
      if(reserve){
        for(var i = tempPath.length; i &lt; endPath.length;i ++){
          tempPath = tempPath.concat(last);
        }
      }
    }
    pathShape.attr(&#39;path&#39;,tempPath);

    pathShape.animate({path : endPath},duration,easing,after);

    function after(){
      pathShape.attr(&#39;path&#39;,toPath);
      callback &amp;&amp; callback();
    }
  },
<span id='Chart-Util-method-getPointAtLength'>  /**
</span>   * 获取path上的点
   * @param  {String} path 路径
   * @param  {Number} length 长度
   * @return {Object}  {x: x-axis ,y: y-axis}
   */
  getPointAtLength : function(path, length){
    return Raphael.getPointAtLength(path,length);
  },
<span id='Chart-Util-method-isPointInsidePath'>  /**
</span>   * 节点是否在指定的Path中
   * @param  {String} path 路径
   * @param {Number} x x坐标
   * @param {Number} y y坐标
   * @return {Boolean} 是否在path中
   */
  isPointInsidePath : function(path, x, y){
    return Raphael.isPointInsidePath(path,x,y);
  },
<span id='Chart-Util-method-getSubpath'>  /**
</span>   * 获取子path
   * @param  {String} path 路径字符串
   * @param  {Number} from 开始的节点
   * @param  {Number} to   结束的节点
   * @return {String} 子路径
   */
  getSubpath : function(path, from, to){
    return Raphael.getSubpath(path,from,to);
  },
<span id='Chart-Util-method-parsePathString'>  /**
</span>   * 将path字符串转换成数组
   * @param  {String} str 字符串
   * @return {Array}  数组
   */
  parsePathString : function(str){
    return Raphael.parsePathString(str);
  },

<span id='Chart-Util-method-parsePathArray'>  /**
</span>   * 将path数组转换成字符串
   * @param  {Array} array 数组
   * @return {String}  字符串
   */
  parsePathArray : function(array){
    if(Util.isArray(array)){
      var path = Util.map(array,function(item){
        var str = item.join(&#39; &#39;);
        return str.replace(/([a-z,A-Z])\s+/,&#39;$1&#39;);
      });
      return path.join(&#39; &#39;);
    }
    return array;
  },

<span id='Chart-Util-method-transformPath'>  /**
</span>   * 平移path
   * @param  {String} path 路径
   * @param  {Array|String|Object} transform 平移路径
   * @return {Array} path数组
   */
  transformPath : function(path,transform){
    return Raphael.transformPath(path,transform);
  },
<span id='Chart-Util-method-snapTo'>  /**
</span>   * 获取逼近的值，用于对齐数据
   * @param  {Array} values   数据集合
   * @param  {Number} value   数值
   * @param  {Number} [tolerance=10] 逼近范围
   * @return {Number} 逼近的值
   */
  snapTo : function(values, value, tolerance){
    if(tolerance){
      return Raphael.snapTo(values, value, tolerance);
    }
    var floorVal = floor(values,value),
      ceilingVal = ceiling(values,value);
    if(isNaN(floorVal) || isNaN(ceilingVal)){
      if(values[0] &gt;= value){
        return values[0];
      }
      var last = values[values.length -1];
      if(last &lt;= value){
        return last;
      }
    }
    

    if(Math.abs(value - floorVal) &lt; Math.abs(ceilingVal - value)){
      return floorVal;
    }
    return ceilingVal;
  },
<span id='Chart-Util-method-snapFloor'>  /**
</span>   * 获取逼近的最小值，用于对齐数据
   * @param  {Array} values   数据集合
   * @param  {Number} value   数值
   * @return {Number} 逼近的最小值
   */
  snapFloor : function(values,value){
    return floor(values,value);
  },
<span id='Chart-Util-method-snapCeiling'>  /**
</span>   * 获取逼近的最大值，用于对齐数据
   * @param  {Array} values   数据集合
   * @param  {Number} value   数值
   * @return {Number} 逼近的最大值
   */
  snapCeiling : function(values,value){
    return ceiling(values,value);
  },
<span id='Chart-Util-method-tryFixed'>  /**
</span>   * 将数字保留对应数字的小数位
   * @param  {Number} value 值
   * @param  {Number} base  基准值
   * @return {Number}  fixed后的数字
   */
  tryFixed : function(value,base){
    return tryFixed(value,base);
  },
<span id='Chart-Util-method-trySet'>  /**
</span>   * 设置值，仅当对象上没有此属性时
   * @param  {Object} obj 对象
   * @param  {String} name  字段名
   * @param  {*} value 值
   */
  trySet : function(obj,name,value){
    if(obj &amp;&amp; !obj[name]){
      obj[name] = value;
    }
    return obj[name];
  },
<span id='Chart-Util-method-highlight'>  /**
</span>   * 将颜色变亮
   * @param  {String} c  颜色
   * @param  {Number} percent 变亮的比例 0 - 1
   * @return {String} 变亮的颜色
   */
  highlight : function(c,percent){
    var color = Raphael.color(c),
      l = color.l * (1 + percent);
    return Raphael.hsl2rgb(color.h,color.s,l).hex;
  },
<span id='Chart-Util-method-dark'>  /**
</span>   * 将颜色变暗
   * @param  {String} c  颜色
   * @param  {Number} percent 变暗的比例 0 - 1
   * @return {String} 变暗的颜色
   */
  dark : function(c,percent){
    var color = Raphael.color(c),
      l = color.l * (1 - percent);
    return Raphael.hsl2rgb(color.h,color.s,l).hex;
  }
});

module.exports = Util;

</pre>
</body>
</html>
